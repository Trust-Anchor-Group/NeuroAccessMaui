# Push Notifications

## End-to-end flow
1. **XMPP capabilities** – When the `TagProfile` downloaded from the broker sets `SupportsPushNotification` to `true` (`Services/Tag/TagProfile.cs`), `XmppService` instantiates a `PushNotificationClient` (`Services/Xmpp/XmppService.cs:300-360`). The client exposes `ReportNewPushNotificationToken`, `ClearPushNotificationRules`, and `AddPushNotificationRule`, which are thin wrappers over the Waher push broker API.
2. **Token acquisition** – `PushNotificationService.CheckPushNotificationToken` (`Services/Push/PushNotificationService.cs`) runs whenever the XMPP connection reaches `Connected` (`Services/Xmpp/XmppService.cs:930-975`). It fetches a token via `IPlatformSpecific.GetPushNotificationToken`, which in turn calls `CrossFirebaseCloudMessaging.Current.CheckIfValidAsync()` and `GetTokenAsync()` on Android (`Platforms/Android/PlatformSpecific.cs:652-704`) and iOS (`Platforms/iOS/PlatformSpecific.cs:380-420`). Tokens are cached in `RuntimeSettings` alongside a `PushNotificationReportDate`.
3. **Reporting & rule management** – If a token changed or has not been reported within 7 days (`ForceTokenReport`), the service calls `XmppService.ReportNewPushNotificationToken`. When the application version changes (detected by `AppInfo.VersionString + "." + AppInfo.BuildString`), it also wipes the remote rules (`ClearPushNotificationRules`) and rebuilds them. Each rule is created via `AddPushNotificationRule` and emits JSON with a `channelId` that corresponds to the MAUI-side notification channel. Rule sets cover chat messages, petitions, identities, contracts, eDaler balances, Neuro Feature tokens, and provisioning requests. All payloads embed localized titles/descriptions via `ServiceRef.Localizer`.
4. **Payload delivery** – The XMPP broker emits Firebase Cloud Messaging (FCM) data payloads. The payloads include `myTitle`, `myBody`, `channelId`, and context-specific fields (contract ids, roster names, etc.).
5. **Rendering notifications**  
   - **Android** – A custom `FirebaseMessagingService` (`Platforms/Android/PushNotificationService.cs`) receives every FCM data push and routes it to `IPlatformSpecific.Show*Notification`. That class ( `Platforms/Android/PlatformSpecific.cs`, Notifications region) builds `NotificationCompat` instances, attaches intents that deep-link into `MainActivity`, and posts them against the channels created in `MainActivity.CreateNotificationChannels`. IDs 100–106 are reused per channel.
   - **iOS** – The app requests the notification token through Firebase, handles silent pushes in `AppDelegate.DidReceiveRemoteNotification`, and re-raises them as local notifications by calling `PlatformSpecific.ShowLocalNotification` (`Platforms/iOS/PlatformSpecific.cs`: Notifications region). The helper checks authorization state, schedules a `UNTimeIntervalNotificationTrigger`, and embeds the payload inside `UserInfo`. `NotificationDelegate` exists to surface foreground notifications but is never wired.
   - **Windows** – `PlatformSpecific` returns empty tokens and provides no-op `Show*Notification` implementations (`Platforms/Windows/PlatformSpecific.cs`), so push is effectively disabled on desktop.

## Permissions & onboarding
- `CustomPermissions/NotificationPermission.cs` encapsulates the prompting logic for iOS (`UNUserNotificationCenter.RequestAuthorizationAsync` + `RegisterForRemoteNotifications`) and Android 13+ (`Permissions.PostNotifications`).  
- The only call site (`UI/Pages/Main/HomeViewModel.cs:64-96`) is commented out, so the app currently never triggers a prompt. Without explicit permission, both Firebase token acquisition and foreground alerts can silently fail.

## Token utilities
- `PushNotificationService.NewToken` caches tokens in-memory and raises `OnNewToken`, but nothing in the solution subscribes to this event and no code calls `NewToken`. The current implementation therefore relies exclusively on `CheckPushNotificationToken` polls to detect rotation.
- `ServiceRef.PlatformSpecific.GetPushNotificationToken` returns `ClientType.Android` or `ClientType.iOS` alongside `PushMessagingService.Firebase`. Those values control what is reported to the broker and which downstream channel the server uses.

## Outstanding work & refactor opportunities
- **Firebase initialization is disabled** – `MauiProgram` comments out `Builder.RegisterFirebaseServices()`, so `CrossFirebase.Initialize` and `UNUserNotificationCenter.Current.Delegate = new NotificationDelegate()` never run. Without explicit initialization, Firebase calls such as `CrossFirebaseCloudMessaging.Current.CheckIfValidAsync()` can throw, and iOS never assigns the delegate that allows foreground notifications.
- **Notification permission flow** – The permission prompt is commented out, so users must enable notifications manually in OS settings. This also means `GetPushNotificationToken` can return empty strings without surfacing the real cause. Re-enable the request at onboarding or during the first visit to the Home page and show error state when permission is denied.
- **Foreground delegate wiring on iOS** – `NotificationDelegate` (which implements `WillPresentNotification` to show alerts while the app is active) is not registered anywhere. Consolidate the duplicated logic shared with `AppDelegate.DidReceiveRemoteNotification` and ensure the delegate is set during startup.
- **FCM token refresh handling** – `PushNotificationService.NewToken` is dead code. Neither the Android `FirebaseMessagingService` nor any component subscribes to `CrossFirebaseCloudMessaging.Current.TokenChanged`. As a result, token updates are only detected via hourly polling once the XMPP client is online. Hook into the Firebase token events (or override `OnNewToken` in `MessagingService`) and call `ServiceRef.PushNotificationService.NewToken` so token rotations and revocations are addressed immediately.
- **Notification rendering on Android** – Each `Show*Notification` uses a static notification ID (100–106). Receiving multiple messages per channel overwrites the previous notification, which makes it easy to miss earlier content. Consider generating unique IDs or grouping notifications with `NotificationCompat.InboxStyle`.
- **Background safety** – `Platforms/Android/PushNotificationService` accesses `ServiceRef.PlatformSpecific` directly. If FCM wakes the process before MAUI has initialized `ServiceRef`, the service will crash. Either lazily create the DI container inside the service or route the payload to OS-native notifications that do not depend on MAUI.
- **Rule definitions** – The giant string literals inside `PushNotificationService` are hard to validate and translate. Moving them into strongly-typed builders (e.g., POCO definitions or embedded resources) would make it easier to unit-test, reuse localization, and add/remove channels without touching the broker logic.
- **Windows parity** – Desktop builds always return empty tokens and override notification methods with no-ops. Either document that push is unsupported on Windows or guard the push UI so the feature is not advertised when `SupportsPushNotification` is false.

## Suggested next steps
1. **Re-enable Firebase bootstrap** – Call `Builder.RegisterFirebaseServices()` once service accounts and entitlement files are in place. As part of the boot hook, set `UNUserNotificationCenter.Current.Delegate` and register `NotificationDelegate`.
2. **Surface permission prompts** – Decide where the notification permission request should occur (onboarding, settings, or first access to messaging) and re-enable the `NotificationPermission` request with UX that handles the denied case gracefully.
3. **Wire token events** – Subscribe to `CrossFirebaseCloudMessaging.Current.TokenChanged` (or override `MessagingService.OnNewToken`) and forward tokens to `PushNotificationService.NewToken`. Remove the unused event once the push lifecycle is unified.
4. **Harden background delivery** – Audit `MessagingService` to ensure it can create notifications even when MAUI services are unavailable. One option is to construct the local notification entirely within the Android service and only delegate to `ServiceRef` when the app is already running.
5. **Refactor rule definitions** – Extract the rule metadata (channel, XPath, message template) into reusable structures so adding a new push type does not require editing 200 lines of interpolated strings. Pair this with automated verification to ensure localized resource keys exist.
6. **Document platform gaps** – Until Windows push is implemented, surface a clear setting/FAQ entry so users understand the limitation.

